[TOC]

# 数据结构

简单来说，底层数据结构一共有 6 种，分别是：

1. 简单动态字符串。
2. 双向链表。
3. 压缩列表。
4. 哈希表。
5. 跳表。
6. 整数数组。

它们和数据类型的对应关系如下图所示：

![8219f7yy651e566d47cc9f661b399f01](../../img/8219f7yy651e566d47cc9f661b399f01.jpg)

- String 类型的底层实现只有一种数据结构，也就是简单动态字符串。
- 而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。

# 键和值用什么结构组织？

## 键

**哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。**

![1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f](../../img/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg)

### rehash

同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。

Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍。
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中。
3. 释放哈希表 1 的空间。

但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。

### 渐进式 rehash

1. Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的**第一个索引位置开始**，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中。
2. 等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。

### rehash 的触发时机和渐进式执行机制

Redis 会使用装载因子（load factor）来判断是否需要做 rehash。装载因子的计算方式是，哈希表中所有 entry 的个数除以哈希表的哈希桶个数。Redis 会根据装载因子的两种情况，来触发 rehash 操作：

1. 装载因子≥1，同时，哈希表被允许进行 rehash。
2. 装载因子≥5。

#### 装载因子≥1

- 在第一种情况下，如果装载因子等于 1，同时我们假设，所有键值对是平均分布在哈希表的各个桶中的，那么，此时，哈希表可以不用链式哈希，因为一个哈希桶正好保存了一个键值对。
- 但是，如果此时再有新的数据写入，哈希表就要使用链式哈希了，这会对查询性能产生影响。在进行 RDB 生成和 AOF 重写时，哈希表的 rehash 是被禁止的，这是为了避免对 RDB 和 AOF 重写造成影响。
- 如果此时，Redis 没有在生成 RDB 和重写 AOF，那么，就可以进行 rehash。否则的话，再有数据写入时，哈希表就要开始使用查询较慢的链式哈希了。

#### 装载因子≥5

- 就表明当前保存的数据量已经远远大于哈希桶的个数，哈希桶里会有大量的链式哈希存在，性能会受到严重影响，此时，就立马开始做 rehash。

### 采用渐进式 hash 时，如果实例暂时没有收到新请求，是不是就不做 rehash 了？

其实不是的。

Redis 会执行定时任务，定时任务中就包含了 rehash 操作。

**在 rehash 被触发后，即使没有收到新请求，Redis 也会定时执行一次 rehash 操作，而且，每次执行时长不会超过 1ms，以免对其他任务造成影响。**

## 值，集合数据

集合类型的底层数据结构主要有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。

### 压缩列表

压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。

和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。

![9587e483f6ea82f560ff10484aaca4a0](../../img/9587e483f6ea82f560ff10484aaca4a0.jpg)

如果要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。

而查找其他元素时\的复杂度就是 O(N) 了。

### 跳表

跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位:

![](../../img/1eca7135d38de2yy16681c2bbc4f3fb4.jpg)

> zset有个ZSCORE的操作，用于返回单个集合member的分数，它的操作复杂度是O(1)，这就是收益于hash table。这个hash table保存了集合元素和相应的分数，所以做ZSCORE操作时，直接查这个表就可以，复杂度就降为O(1)了。
>
> 而跳表主要服务范围操作，提供O(logN)的复杂度。

# 不同操作的复杂度

## 单元素操作

每一种集合类型对单个数据实现的增删改查操作。

例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。

这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)。

Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。

## 范围操作

是指集合类型中的遍历操作，可以返回集合中的所有数据，比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。

这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。

不过，Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），**这类操作实现了渐进式遍历**，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。

## 统计操作

是指集合类型对集合中所有元素个数的记录，例如 LLEN 和 SCARD。

这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。

## 例外情况

是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。

这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。

# 整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？

1. 内存利用率，数组和压缩列表都是非常紧凑的数据结构，**分配的是一块连续的内存空间**，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，**提高内存的利用率，节省空间而且也能避免一些内存碎片。**

# Redis 为什么用单线程？

多线程编程模式面临的共享资源的并发访问控制问题。

## Redis 6.0 版本为什么又引入了多线程？

Redis 的瓶颈不在 CPU ，而在内存和网络，内存不够可以增加内存或通过数据结构等进行优化，但 Redis 的网络 IO 的读写占用了发部分 CPU 的时间，如果可以把网络处理改成多线程的方式，性能会有很大提升。

1.充分利用服务器的多核资源。
2.多线程分摊 Redis 同步 IO 读写负荷。

**只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。**

# 单线程 Redis 为什么那么快？

1. Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。
2. Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。

