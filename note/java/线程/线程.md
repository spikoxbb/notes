[TOC]

# 线程生命周期

当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。

在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。

## 新建状态(New)

当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，**此时仅由 JVM 为其分配内存，并初始化其成员变量的值。**

## 就绪状态（RUNNABLE）

当线程对象调用了 start()方法之后，该线程处于就绪状态。**JVM会为其创建方法调用栈和程序计数器，等待调度运行。**

## 运行状态（RUNNING）

如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。

## 阻塞状态（BLOCKED）

阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入就绪状态才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种：

1. 等待阻塞:

   运行的线程执行 obj.wait()方法，JVM 会把该线程**放入等待队列(waitting queue)中。**

2. 同步阻塞:

   运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程**放入锁池(lock pool)中。**

3. 其他阻塞：

   运行的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。

   当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入就绪状态状态。

## 线程死亡（DEAD）

线程会以下面三种方式结束，结束后就是死亡状态。

1. 正常结束：

   run()或 call()方法执行完成，线程正常结束。

2. 异常结束：

   线程抛出一个未捕获的 Exception 或 Error。

3. 调用 stop：

   直接调用该线程的 stop()方法来结束该线程。该方法通常容易导致死锁，不推荐使用。

# 终止线程的方式

## 正常运行结束

程序运行结束，线程自动结束。

## 使用退出标志退出线程

一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：

最直接的方法就是设一个 boolean 类型的标志，并通过设置这个标志为 true 或 false 来控制 while

循环是否退出，代码示例：

```java
public class ThreadSafe extends Thread {
  public volatile boolean exit = false; 
  public void run() { 
    while (!exit){
      //do something
    }
  } 
}
```

## **Interrupt** 方法结束线程

使用 interrupt()方法来中断线程有两种情况：

1. 线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。

2. 线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。

   ```java
   public class ThreadSafe extends Thread {
     public void run() { 
       while (!isInterrupted()){ //非阻塞过程中通过判断中断标志来退出
         try{
           Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出
         }catch(InterruptedException e){
           e.printStackTrace();
           break;//捕获到异常之后，执行 break 跳出循环
         } 
       }
     } 
   }
   ```

## **stop** 方法终止线程（线程不安全）

程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：

1. thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且**会释放子线程所持有的所有锁。**
2. 一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性。

#  **sleep** & wait

- sleep()方法是属于 Thread 类中的。而 wait()方法，则是属于Object 类中的。
- sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。
- 在调用 sleep()方法的过程中，线程不会释放对象锁。而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。

# Java中用到的线程调度

## 抢占式调度

抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。

## 协同式调度

协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。

线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。