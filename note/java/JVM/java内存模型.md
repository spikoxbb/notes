[TOC]

现代计算机加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器的缓冲。

为了使处理器内部的运算尽可能被充分利用，处理器可能会对输入代码进行乱序执行优化。

与处理器的乱序执行优化类似，Java的即时编译器也有指令重排序优化。

# Java内存模型

用JMM来屏蔽硬件和操作系统内存的差异来实现让Java在各种平台下都能达到一致的内存访问效果。

## 主内存与工作内存

JMM规定所有的变量都存储在主内存（也就是主存），每条线程有自己的工作内存（也就是高速缓存）。

工作内存都保存了所使用的变量的主内存副本，线程对变量的操作都必须在工作内存中执行。

> 对象的引用，字段有可能复制，整个对象不太可能。

# 内存间的交互操作

JMM定义了8种操作：

- **lock（锁定）**：作用于主内存的变量，把一个变量标识为一条线程独占状态。
- **unlock（解锁）**：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- **read（读取）**：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
- **load（载入）**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- **use（使用）**：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- **store（存储）**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
- **write（写入）**：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

- 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
- 不允许read和load、store和write操作之一单独出现
- 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

## volatile

1. 保证此变量对所有线程可见。
2. 禁止指令重排序。

**volatile修饰的变量，赋值后多执行了一个"lock addl $0x0,(%esp)"操作，相当于一个内存屏障。**

**addl $0x0,(%esp)是一个空操作，作用是将本处理器的缓存写入内存。所以其他处理器看到的是失效的。**

这就意味着所有之前的操作都已经执行完成。

**1.** 只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作，并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load/read动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值。

>  就是read->load->use 这几个指令以原子形式执行。

**2.** 只有当线程T对变量V执行的前一个动作的是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store，write动作相关联，必须联系一起出现（这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改。

> assign->store->write 这几个指令以原子的形式执行。

**3.**假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对应变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G想要的对变量W的read或write动作。如果A先于B，那么P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。

## long & double

JMM允许虚拟机将没有被volatile修饰的64位数据的读写操作分为两次32位执行。

目前商用64位虚拟机不会出现非原子性操作。对于32位有可能。

- JDK9HotSpot增加了-XX:AlwaysAtomicAccesses来约束虚拟机对所有数据类型进行原子性访问。
- 现代中央处理器都包含专门用于处理浮点数的浮点运算器，32位也无妨。

# 原子性 & 可见性 & 有序性

## 原子性 

JMM保证原子性的那6个操作。

尽管虚拟机未把lock, unlock直接开放给用户使用，但是monitorenter和monitorexit隐式地用了——synchronized。

## 可见性

除了volatile，保持可见性的还有final，synchronized。

对一个变量unlock之前，必须把变量同步回主内存（write和store操作）。

## 有序性

synchronized和volatile都可保证。



