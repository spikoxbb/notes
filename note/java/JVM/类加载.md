[TOC]

# 类加载的时机

![截屏2020-12-16 下午5.37.50](/Users/spiko/Downloads/study/notes/img/截屏2020-12-16 下午5.37.50.png)

解析阶段不一定，可能在初始化之后开始（多态）。

虚拟机没有定义什么时候进行类的加载，只定义了初始化（类加载在之前）：

1. 遇到new, getstatic, putstatic, invokestatic这四条字节码指令时，如果类型没有初始化需要先初始化。
   - 使用new关键字的时候。
   - 读取或设置一个静态变量时候（final修饰的除外，已在编译器把结果放入常量池了）。
   - 调用静态方法时。
2. 使用java.lang.reflect的方法对类进行反射调用时，如果类型没有初始化需要先初始化。
3. 初始化类的时候，如果其父类还没有初始化，先触发其父类的初始化。
4. 虚拟机启动时会先初始化主类。
5. 当一个接口定义了默认方法，如果有这个接口的实现类发生了初始化，那该接口在其之前初始化。

**这叫做主动引用，被动引用不会初始化。**

- 通过主类引用父类的静态字段，不会导致子类的初始化。
- 通过数组定义来引用类，不会触发次类的初始化。
  - 只会导致“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化。它是由一个虚拟机自动生成的直接继承与Object的子类，创建动作由字节码指令newarray触发。
- 引用常量不会初始化。
- 接口在初始化时，不会要求其父接口初始化。

# 类加载的过程

## 加载

1. 通过一个类的全限定名来获取此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化成方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的Class对象。

数组类不通过类加载器创建，是虚拟机直接在内存中动态创造出来的。创建过程：

1. 如果数组的组件类型是引用类型，那就递归加载这个组件类型。

   数组被标志在加载这个组件类型的类加载器的类名称空间上。

2. 如果数组的组件类型不是引用类型，数组被标志为与引导类加载器关联。

3. 数组类的可访问性和它的组件类型的可访问性一致。

## 验证

### 文件格式验证

是否符合Class文件的格式规范。

### 元数据验证

对字节码描述的信息进行语义分析。

1. 是否有父类（Object）。
2. 这个类的父类是否继承了不允许被继承的类。
3. 如果不是抽象类，是否实现了所有方法。
4. 类中的字段，方法是否与父类产生矛盾。

……

### 字节码验证

对类的方法体进行校验分析。

### 符号引用验证

发生在虚拟机将符号引用转为直接引用的时候——在解析阶段发生。

## 准备

为类中的变量分配内存并设置类变量初始值的阶段。

```java
public static int value = 123;
```

在准备阶段后初始值为0；

```java
public static final int value = 123;
```

在准备阶段后初始值为123；

## 解析

虚拟机将常量池内的符号引用转为直接引用。

除invokedynamic（lambda表达式）以外，虚拟机实现可以对第一次解析的结果进行缓存，在运行时直接引用常量池的记录，并标志为已解析状态。

### 类或接口的解析

​    假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：

1. 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。
2. 如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。
3. 如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。

### 字段解析

​    要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。

1. 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
2. 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和他的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
3. 否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段直接引用，查找失败。
4. 否则，查找失败，抛出java.lang.NoSuchFieldError异常。

如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。

### 类方法解析

​    类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。

1. 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。
2. 如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4. 否则，在类C实现的接口列表及他们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象，这时查找结束，抛出java.lang.AbstractMethodError异常。
5. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。

 最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。

### 接口方法解析

  接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。

1. 与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。
2. 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在接口C的父接口中递归查找，直到java.lang.Object（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。
5. 由于接口中的所有方法默认都是public，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。

## 初始化

初始化阶段就是执行类构造器<client>方法的过程。javac编译的自动产物。

- 编译器会在将所有类变量的赋值动作和静态语句块（static {}块）中的语句合并产生。

静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。

并给出一个示例：

```java
public class MyClass {
  static {
    i = 0; //给变量赋值可以正常通过
    System.out.println(i); //编译器提示非法向前引用
  }
  static int i = 1;
}
```

是因为jvm在加载类后链接里的准备阶段已经赋了默认值。这时初始化还没到，初始化的时候静态变量赋值，静态代码块执行。至于为什么不能调用后面的变量，完全是jvm规范。

- 父类的<client>先于子类，所以Object最先执行。
- 如果一个类中没有静态语句块，那么编译器可以不为这个类生成<client>()方法。
- 接口和类一样都会生成<client>()方法，但执行接口的<client>()方法不需要先执行父接口的<client>()。接口的实现类在初始化时不会执行接口的<client>()方法。
- 如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<client>()，其他线程都需要阻塞等待，直到活动线程执行<client>()方法完毕。

# 类加载器

就是通过一个类的权限定名来获取描述此类的二进制字节流这个动作的代码模块。

启动类加载器由C++编写，是虚拟机的一部分。

其他的都是Java编写，全部继承自ClassLoader，独立于虚拟机外。

## 双亲委派模型

- 启动类加载器：负责将存放在<JAVA_HOME>lib目录中的或被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，如果需要把加载请求委托给引导类加载器，那直接使用null代替即可。
- 扩展类加载器：负责加载<JAVA_HOME>libext目录中或被java.ext.dirs系统变量所制定的路径中所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（系统类加载器）：负责加载用户路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。

双亲委派模型的工作过程：

如果一个类加载器受到了类加载请求，首先它不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，因此所有的加载请求最终因该传送到顶层的启动类加载器中，只有父类加载器反馈自己无法完成这个请求时，子加载器才会尝试自己去加载。

实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass()方法中，代码实现就是首先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。

如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。