[TOC]

# 运行时数据区域

![截屏2020-12-14 下午5.01.55](../../../../notes/img/截屏2020-12-14 下午5.01.55.png)

## 程序计数器

当前线程所执行的字节码的行号指示器。每个线程都有一个独立的程序计数器。

- 如果线程正在执行的是一个Java方法，这个计数器就记录的是正在执行的虚拟机字节码指令的地址。
- 如果正在执行的是一个native方法，这个计数器就为空。

## Java虚拟机栈

每个方法执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。

### 局部变量表

局部变量表存放了**编译期可知的**

1. 各种Java虚拟机基本数据类型。
2. 对象引用。
3. returnAddress类型。
   - returnAddress 类型的值是指向字节码的指针，不管是物理机还是虚拟机，运行时内存中的数据总归可分为两类：代码，数据。
   - **对于冯诺依曼结构的计算机，指令数据和数值数据都存储在内存中，而哈弗结构的计算机，将程序指令与数据分开存储。**
   - 对于 JVM 来说，程序就是存储在方法区的字节码指令，而 returnAddress 类型的值就是指向特定指令内存地址的指针。

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）表示，**64位的long和double类型的数据会占用两个变量槽**，其余的数据只占用一个。

所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小（指的变量槽的数量）。

- 如果线程请求的栈深度大于虚拟机所允许的深度将抛出StackOverflowError异常。

- 如果Java虚拟机栈允许动态扩展，当栈无法申请到足够的内存将抛出OOM。

  HotSpot虚拟机栈是不允许动态扩展的，Classic虚拟机可以。所以HotSpot虚拟机是不会因为Java虚拟机栈无法动态扩展而导致OOM的。只要线程申请栈空间成功了就不会有OOM，但如果申请失败了还是会有OOM的。

## 本地方法栈

是为虚拟机使用到的本地方法服务。

有的虚拟机（如HotSpot）直接把本地方法栈和Java虚拟机栈合二为一。

与Java虚拟机栈一样，本地方法栈也会在栈深度溢出时抛出StackOverflowError和动态扩展失败时抛出OOM的。

## Java堆

存放对象实例。

没有内存完成实例分配也无法扩展抛出OOM。

## 方法区

用于存储已经被虚拟机加载的：

1. 类型信息。
2. 常量。
3. 静态变量。
4. 即时编译器编译后的代码缓存等数据。

JDK1.7HotSpot已经把原来放在永久代的字符串常量池，静态变量等移出。

而到了JDK1.8废弃了永久代该用在本地内存中实现的元空间来代替。

方法区没有办法满足新的内存分配需求将抛出OOM。

### 运行时常量池

运行时常量池是方法区的一部分。

Class文件除了有**类的版本，字段，方法，接口等描述信息**外，还有**常量池表**，用于**存放编译器生成的各种字面量和符号引用**，这部分内容将在类加载后存放到方法区的运行时常量池。

**除了保存Class文件中描述的符号引用外，还会把符号引用翻译出来的直接引用也存放到运行时常量池。**（动态）

自然受到方法区的内存限制，没有办法满足新的内存分配需求将抛出OOM。

## 直接内存

不是虚拟机运行时数据区的一部分，但被频繁使用而且也会OOM。

JDK1.4引入的NIO，可以使用Native函数库直接分配堆外内存，然后通过Java堆的DirectByteBuffer作为这块内存的引用来操作，避免了Java堆和Native堆来回复制对象。

受到本机总内存和处理器寻址空间的限制。如果配置虚拟机参数的忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而动态扩展的时候OOM。