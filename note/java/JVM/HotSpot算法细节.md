[TOC]

# 根节点枚举

根节点枚举这一步是要暂停用户线程的，不会出现分析过程中根节点集合的对象引用关系还在不断变化的情况。

查找引用链这个过程可以做到与用户线程一起并发。

## 记录OopMap

**使用一组称为OopMap的数据结构来来得到什么地方存放着对象引用。**

- **一旦类加载过程完成**，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来。
- 在**即时编译过程中**也会**在特定的位置**记录下栈里和寄存器里哪些位置是引用。

## 安全点

如果为每一条指令都生成OopMap，将会需要大量的额外存储空间。

**前面所说的特定的位置就是安全点。**

安全点位置的选择基本上是以“是否具有让程序长时间执行的特征”选定的。

**为什么把这些位置设置为jvm的安全点呢？**

主要目的就是**避免程序长时间无法进入safepoint**，比如JVM在做GC之前要等所有的应用线程进入到安全点后VM线程才能分派GC任务 ，如果有线程一直没有进入到安全点，就会导致GC时JVM停顿时间延长。比如写了一个超大的循环导致线程一直没有进入到安全点，GC前停顿了8秒。

**如何让线程跑到最近的安全点？**

- 抢先式中断

  1. 把所有用户线程全部中断。
  2. 发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会儿再重新中断，知道跑到安全点上。

- 主动式中断

  1. 设置一个标记位，各个线程执行过程中不停主动去轮询这个标志。
  2. 标志为真时就自己在最近的安全点上主动中断挂起（轮询的地方和安全点是重合的）。

  **test指令就是HotSpot生成的轮询指令。**

## 安全区域

用户线程处于Sleep或者Blocked状态就无法响应虚拟机的中断请求，不能走到安全点挂起自己。

**安全区域是指能够确保在某一段代码片段之中，引用关系不会变化。**

1. 用户线程进入安全区域首先以标志自己进入安全区域。
2. 当线程要离开安全区域时**要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集其他过程中需要暂停用户线程的阶段）。**
   - 如果完成了就继续执行。
   - 如果没有，就必须一直等待，**直到收到可以离开安全离区域的信号。**

# 记忆集与卡表

**解决对象跨代引用的问题。**

**记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。**

记录精度：

## 字长精度

每个记录精确到一个机器字长，该字包含跨代指针。

## 对象精度

每个记录精确到一个对象，该对象里有字段包含跨代指针。

## 卡精度

每个记录精确到一块内存区域，该内存区域内有对象里有字段包含跨代指针。

指的是用一种称为“卡表”的方式去实现记忆集。

**HotSpot的卡表是一个字节数组：**

> 用byte不用bit是因为都是按照byte寻址的。

```java
CARD_TABLE[this_address >> 9] = 0;
```

CARD_TABLE每一个元素都对应着一块特定大小的内存块（卡页）。

可以看出HotSpot的卡页是2的9次幂。

**只要卡页有一个对象的字段存在着跨代指针，那就将对应的卡表的数组元素的值标志为1。垃圾收集时，筛选出变脏的元素，把他们加入GC Roots一并扫描。**

# 写屏障

**如何在对象赋值的那一刻去更新维护卡表？**

写屏障可以看作是虚拟机层面对“引用类型赋值”的这个动作的AOP切面。在赋值前的部分的写屏障叫做写前屏障，在赋值后的部分的写屏障叫做写后屏障。

假设处理器的缓存行的大小是64字节，一个卡表元素1字节，所以64个卡表元素共享缓存行。

**为了避免伪共享问题，先检查卡表标记，只有未被标记过时才将其标记为变脏。**

**JDK7新增-XX:+UseCondCardMark来决定是否开启更新条件判断。**

# 并发的可达性分析-三色标记

- 白色：对象尚未被垃圾收集器访问过。
- 黑色：已经被垃圾收集器访问过，且这个对象所有的引用都被扫描过。
- 灰色：已经被垃圾收集器访问过，但这个对象至少存在一个引用未被扫描过。

## 并发扫描时的对象消失问题

- **增量更新**

  当黑色对象插入新的指向白色对象的引用关系时，将这个新插入的引用记录下来，等并发扫描结束后，**再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。**

  **记录黑色对象a指向白色对象b这条引用关系。****写后屏障**

- **原始快照**

  当灰色对象要删除指向白色对象的引用关系时，将这个要删除的引用记录下来，等并发扫描结束后，**再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。**

  **记录灰色对象a删除白色对象b这条引用关系。****写前屏障**

  **会造成浮动垃圾。**

**这都是通过写屏障实现的。**

**CMS基于增量更新来做的，G1，Shenandoah基于原始快照来做的。**

