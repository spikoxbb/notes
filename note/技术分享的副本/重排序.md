[TOC]

# 重排序

## 数据依赖

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。

```java
// 写后读
a = 1;
b = a; 
//写后写
a = 1;
a = 2;
//读后写
a = b;
b = 1;
```

以上只要重排序两个操作的执行顺序，程序的执行结果都被改变。**但是数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。**

> as-if-serial 指不管怎么重排序，（单线程）程序的执行结果不能被改变。编译器和处理器都必须遵守 as-if-serial 语义。但是如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。

## 多线程下的重排序

```java
//假设有两个线程A和B，A首先执行write()，然后B执行reade()。线程B在执行操作4时，能否看到A在操作1对共享变量 a的写入？
class Example {
int a = 0;
boolean flag = false;

public void write() {
    a = 1;                   //1
  //用来标识a是否已被写入
    flag = true;             //2
}

Public void read() {
    if (flag) {                //3
        int i =  a * a;        //4
        ……
    }
}
}  
```

由于操作1和操作2没有数据依赖关系，操作3和操作4没有数据依赖关系，因此编译器和处理器可以对他们进行重排序。

- 如果操作1和操作2做了重排序。那么A首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量a。此时a 还没有被线程 A 写入，那么结果也和预期的不一样。

- 操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a*a，然后把计算结果临时保存到一个名为**重排序缓冲**的硬件缓存中。当接下来操作3的条件判断为真时，就把该计算结果写入变量i中。

  > **重排序缓冲**:

## 编译器指令重排

```java
//线程 1 
1：x2 = a ; 
2: b = 1; 
//线程 2
3: x1 = b ;
4: a = 2 ;
```

由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的。

## 指令集并行的重排序

指令集并行的重排序是对CPU的性能优化。

```java
a = b + c ;
d = e - f ;
------
  LW R1,b
  LW R2,c
  ADD R3, R1, R2
  SW a,R3
  LW R4,e 
  LW R5,f
  SUB R6,R4,R5
  SW d,R6
```

上述指令可能会有停顿的地方，同时也会影响后续指令的执行，可能需要经过1个或几个指令周期才可能恢复正常，停顿的原因可能是部分数据还没准备好，如ADD需要R1，R2，而此时R2的MEM操作没有完成，这样计算就无法进行，**然后停顿会造成CPU性能下降。**

既然ADD指令需要等待，那么就利用等待的时间去做别的事情，把`LW R4,e` 和 `LW R5,f` 移动到前面执行，毕竟`LW R4,e` 和 `LW R5,f`执行并没有数据依赖关系，这样指令流水线也无需中断了，CPU的性能也能带来很好的提升。

## 内存系统的重排序



----

### volatile不会将内存变量和其他内存操作一起重排序。

- 如双重检查锁构造单例，如果没有使用volatile修饰singleton，就可能会造成错误。这是因为使用new关键字初始化一个对象的过程并不是一个原子的操作，它分成三个步骤进行：a. 给 singleton 分配内存　 b. 调用 Singleton 的构造函数来初始化成员变量　 c. 将 singleton 对象指向分配的内存空间（执行完这步 singleton 就为非 null 了）

  如果虚拟机存在指令重排序优化，则步骤b和c的顺序是无法确定的。如果A线程率先进入同步代码块并先执行了c而没有执行b，此时因为singleton已经非null。这时候线程B判断singleton非null并将其返回使用，因为此时Singleton实际上还未初始化，自然就会出错。synchronized可以解决内存可见性，但是不能解决重排序问题。

- **有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障**（指令重排序时不能把后面的指令重排序到内存屏障之前的位置）。

  - 在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；

  - 在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。

java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合：

-  LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
-  StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
-  LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
-  StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能

**在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障； 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；**

----

### 未被正确发布对象，其他线程看到的域为空引用或旧值

```java
public class Holder {
  private int n; 
  public Holder(int n){
      this.n = n;
  }
  public void assertSanity() { 
    if (n != n) {
        throw new AssertionError("This statement is false"); 
    }
  }
}

// Unsafe publication
public Holder holder;
public void initialize() {
     holder = new Holder(42);
}
```

其他线程可能看到的Holder域是一个空引用或者之前的旧值。

在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序.

**`final`在对象的构造函数中设置对象的字段；并且不要在对象的构造函数完成之前在另一个线程可以看到它的地方编写对正在构造的对象的引用。如果执行此操作，则当另一个线程看到该对象时，该线程将始终看到该对象`final`字段的正确构造版本。它还将看到那些`final` 字段所引用的任何对象或数组的版本至少与这些`final`字段一样最新。**

1. JMM 禁止编译器把 final 域的**写重排序到构造函数之外。**
2. **编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。**这个屏障禁止处理器把 final 域的写重排序到构造函数之外。
3. 写普通域的操作可能被编译器重排序到了构造函数之外
4. "初次读对象引用"与"初次读该对象包含的 final 域"，JMM 禁止处理器重排序这两个操作， **编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。**初次读对象引用与初次读该对象包含的 final 域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作（**读引用|loadload|读final域**）。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如 alpha 处理器），这个规则就是专门用来针对这种处理器（ **alpha 处理器因此可能出现先读普通域再读引用导致值不对**）。