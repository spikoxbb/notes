##### 索引是个什么样的数据结构呢?

在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.

2. ##### Hash索引和B+树所有有什么区别或者说优劣呢?

   hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.

   B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.

   hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.

   ```
   聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据,实际的数据保存在叶子页中
   非聚簇索引：又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。
   ```

   当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.

   hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.AAAA和AAAAB的索引没有相关性.

3. ##### 上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?

   在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引. 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.

4. ##### 非聚簇索引一定会回表查询吗?

   不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.

   举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age < 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.

5. ##### 在建立索引的时候,都有哪些需要考虑的因素呢?

   建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.防止过多的所有对表造成太大的压力.

6. #####  联合索引是什么?为什么需要注意联合索引中的顺序?

   MySQL使用索引时需要索引有序,假设现在建立了"name,age,school"的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.

7. ##### 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?

   - 当mysql分析全表扫描比使用索引快的时候不使用索引.
   - 当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.
   - 隐式类型转换
   - 对索引列进行运算
   - like "%_" 百分号在前（可采用在建立索引时用reverse(columnName)这种方法处理）

8. ##### Innodb使用的是哪种隔离级别呢?

   InnoDB默认使用的是可重复读隔离级别.

9. ##### MySQL锁?

   ### MyISAM表锁

   MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 

   MySQL的表级锁有两种模式：**表共享读锁（Table Read Lock）**和**表独占写锁（Table Write Lock）**。

   **写锁阻塞**:lock table t_name write------unlock tables;//只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。 

   **读锁阻塞**:lock table t_name read------unlock tables;//这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；更新本表也会报错。同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。 

   - MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。

   - Lock tables orders read local, order_detail read local;//其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录.

   - MySQL不支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；

   - 当使用LOCK TABLES时，不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁定多少次，否则也会出错:

   - select a.first_name,a.last_name,b.first_name,b.last_name from actor a,actor b .....//报错

     lock table actor as a read,actor as b read;

   - 可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺： 

     show status like 'table%';//如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。

   - MyISAM表的读和写是串行的，但在一定条件下，MyISAM表也支持查询和插入操作的并发进行。

     - 当concurrent_insert设置为0时，不允许并发插入。
     - 当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。
     - 当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。

   - 一个进程请求某个 MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后 到，写锁也会插到读锁请求之前！这是因为MySQL认为写请求一般比读请求要重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原 因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。

   ### InnoDB

   InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。

   可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：

   show status like 'innodb_row_lock%';

   InnoDB实现了以下两种类型的行锁：

   - 共享锁（Ｓ）就是多个事务只能读数据不能改数据。 
   - 排他锁（Ｘ）指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。mysql InnoDB引擎默认的修改数据语句：update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。所以加过排他锁的数据行在其他事务中是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。
   - 意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
   - 意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。
   - InnoDB行锁是通过给索引上的索引项加锁来实现的。只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。
   - 意向锁的主要作用是提升存储引擎性能，innoDB中的S锁和X锁是行锁，**每当事务到来时，存储引擎需要遍历所有行的锁持有情况，性能较低**，因此**引入意向锁**，检查行锁前先检查意向锁是否存在，如果存在则阻塞线程。
   - 当用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的 索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁 （Next-Key锁）。 

10. **主键使用自增ID还是UUID?**

    因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.

    关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.

11. **字段为什么要求定义为not null?**

    含有空值的列很难进行查询优化，而且对表索引时不会存储NULL值的，所以如果索引的字段可以为NULL，索引的效率会下降很多。因为它们使得索引、索引的统计信息以及比较运算更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节。

12. **如果要存储用户的密码散列,应该使用什么字段进行存储?**

    char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，mysql就会在它的右边用空格字符补足．（在检索操作中那些填补出来的空格字符将被去掉）在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）。

    密码散列,盐,用户身份证号等固定长度的字符串应该使用char而不是varchar来存储,这样可以节省空间且提高检索效率.

13. InnoDB和MyISAM有什么区别?

    - InnoDB支持事物，而MyISAM不支持事物

    - InnoDB支持行级锁，而MyISAM支持表级锁

    - InnoDB支持MVCC, 而MyISAM不支持

      ```java
      InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，没开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.
      
      InnoDB会根据以下两个条件检查每行记录: 
      a.InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的. 
      b.行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除. 
      只有a,b同时满足的记录，才能返回作为查询结果.
      ```

    - InnoDB支持外键，而MyISAM不支持

      ```
      alert table 表名 add constraint FK_ID foreign key(外键字段名) references 外表表名(主键字段名)
      ```

    - InnoDB不支持全文索引，而MyISAM支持。

      ```java
      //CREATE FULLTEXT INDEX ft_email_name ON `student` (`name`)
      其背后的原理都是倒排索引
      ```

      

14. **varchar(10)和int(10)代表什么含义?**

    varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度。int的10只是代表了展示的长度,不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.

15. **MySQL的binlog有有几种录入格式?分别有什么区别?**

    binlog是二进制日志文件，用于记录mysql的数据更新或者潜在更新(比如DELETE语句执行删除而实际并没有符合条件的数据)，在mysql主从复制中就是依靠的binlog.在mysql中开启binlog需要设置my.cnf中的log_bin参数，另外也可以通过binlog_do_db指定要记录binlog的数据库和binlog_ignore_db指定不记录binlog的数据库。对运行中的mysql要启用binlog可以通过命令`SET SQL_LOG_BIN=1`来设置。

    innodb引擎中的redo/undo log与mysql binlog是完全不同的日志:

    1. redo/undo log是innodb层维护的，而binlog是mysql server层维护的，跟采用何种引擎没有关系，记录的是所有引擎的更新操作的日志记录。

    2. redo/undo日志在事务执行过程中会不断的写入;binlog是在事务最终commit前写入的，

       ```java
       大部分情况下 Redo是物理日志，记录的是数据页的物理变化。而逻辑Redo日志，不是记录页面的实际修改，而是记录修改页面的一类操作.
       //Redo 的组成:
       1.内存中重做日志缓冲 (redo log buffer),是易失的，在内存中
       2.重做日志文件 (redo log file)，是持久的，保存在磁盘中
       在数据页修改完成之后，在脏页刷出磁盘之前，写入redo日志。注意的是先修改数据，后写日志.redo日志比数据页先写回磁盘聚集索引、二级索引、undo页面的修改，均需要记录Redo日志。
       更新事务：
       第一步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝
       第二步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值
       第三步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式
       第四步：定期将内存中修改的数据刷新到磁盘中
       InnoDB是事务的存储引擎，其通过Force Log at Commit 机制实现事务的持久性，即当事务提交时，先将 redo log buffer 写入到 redo log file 进行持久化，待事务的commit操作完成时才算完成。这种做法也被称为 Write-Ahead Log(预先日志持久化)，在持久化一个数据页之前，先将内存中相应的日志页持久化。默认情况下，InnoDB存储引擎都需要调用一次 fsync操作,因为重做日志打开并没有 O_DIRECT选项，所以重做日志先写入到文件系统缓存。为了确保重做日志写入到磁盘，必须进行一次 fsync操作。fsync是一种系统调用操作，其fsync的效率取决于磁盘的性能，因此磁盘的性能也影响了事务提交的性能，也就是数据库的性能。(O_DIRECT选项是在Linux系统中的选项，使用该选项后，对文件进行直接IO操作，不经过文件系统缓存，直接写入磁盘)。
       Force Log at Commit机制就是靠InnoDB存储引擎提供的参数 innodb_flush_log_at_trx_commit来控制的
       1.当设置参数为1时，（默认为1），表示事务提交时必须调用一次 fsync 操作，最安全的配置，保障持久性
       2.当设置参数为2时，则在事务提交时只做 write 操作，只保证将redo log buffer写到系统的页面缓存中，不进行fsync操作，因此如果MySQL数据库宕机时 不会丢失事务，但操作系统宕机则可能丢失事务
       3.当设置参数为0时，表示事务提交时不进行写入redo log操作，这个操作仅在master thread 中完成，而在master thread中每1秒进行一次重做日志的fsync操作，因此实例 crash 最多丢失1秒钟内的事务。（master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性）
       //fsync和write操作实际上是系统调用函数，fsync操作 将数据提交到硬盘中，强制硬盘同步，将一直阻塞到写入硬盘完成后返回，大量进行fsync操作就有性能瓶颈，而write操作将数据写到系统的页面缓存后立即返回，后面依靠系统的调度机制将缓存数据刷到磁盘中去,其顺序是user buffer——> page cache——>disk。
       //undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。有两个作用：
       1.用于事务的回滚
       2.MVCC
       //DML操作修改聚簇索引前，记录undo日志,二级索引记录的修改，不记录undo志(undo页面的修改，同样需要记录redo日志。)
       undo log分为：
       1. insert undo log
       2. update undo log
       ```

       

    binlog刷新到磁盘的时机跟sync_binlog参数相关，如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新，而如果设置为不为0的值则表示每sync_binlog次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。

    通过命令`SHOW MASTER LOGS`可以看到当前的binlog数目。可以通过设置`expire_logs_days`来指定binlog保留时间，要手动清理binlog可以通过指定binlog名字或者指定保留的日期，命令分别是:`purge master logs to BINLOGNAME;`和`purge master logs before DATE;`。

    binlog格式分为statement，row以及mixed三种，

    - Statement：statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.
    - row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题
    - mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row

    新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.

16. **超大分页怎么处理?**

    超大的分页一般从两个方向上来解决.

    - 数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于`select * from table where age &gt 20 limit 1000000,10`这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 可以修改为`select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)`.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 
    - 靠缓存

17. **关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?**

    慢查询的优化首先要搞明白慢的原因是什么? 是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?

    load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.

    分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.

    如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.

18. **横向分表和纵向分表,可以分别举一个适合他们的例子吗?**

    横向分表是按行分表.假设我们有一张用户表,主键是自增ID且同时是用户的ID.数据量较大,有1亿多条,那么此时放在一张表里的查询效果就不太理想.我们可以根据主键ID进行分表,无论是按尾号分,或者按ID的区间分都是可以的. 假设按照尾号0-99分为100个表,那么每张表中的数据就仅有100w.这时的查询效率无疑是可以满足要求的.

    纵向分表是按列分表.假设我们现在有一张文章表.包含字段`id-摘要-内容`.而系统中的展示形式是刷新出一个列表,列表中仅包含标题和摘要,当用户点击某篇文章进入详情时才需要正文内容.此时,如果数据量大,将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度.我们可以将上面的表分为两张.`id-摘要`,`id-内容`.当用户点击详情,那主键再来取一次内容即可.而增加的存储量只是很小的主键字段.代价很小.

19. **什么是存储过程？有哪些优缺点？**

    存储过程是一个预编译的代码块，执行效率比较高.

20. **说一说三个范式**

    第一范式: 每个列都不可以再拆分. 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.

21. ### MySQL的复制原理以及流程

    **主**：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；

    **从**：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；

    **从**：sql执行线程——执行relay log中的语句；

    MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点.

    **主节点 binary log dump 线程**

    当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。

    **从节点I/O线程**

    当从节点上执行`start slave`命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 发来的更新之后，保存在本地relay-log中。

    **从节点SQL线程**

    SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性