[TOC]

# 脏页

当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。

内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。

## 什么情况会引发数据库的 flush 过程呢？

1. InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。

   ![a25bdbbfc2cfc5d5e20690547fe7f2e5](../../img/a25bdbbfc2cfc5d5e20690547fe7f2e5.jpg)

   把 checkpoint 位置从 CP 推进到 CP’，**就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都 flush 到磁盘上。**之后，图中从 write pos 到 CP’之间就是可以再写入的 redo log 的区域。

2. 系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。

   **不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿 redo log 出来应用不就行了？**

   这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：

   - 一种是内存里存在，内存里就肯定是正确的结果，直接返回。
   - 另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。

3. MySQL 认为系统“空闲”的时候就会见缝插针地找时间，只要有机会就刷一点“脏页”。

4. MySQL 正常关闭的情况。这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。

# 四种场景对性能的影响

第三种情况是属于 MySQL 空闲时的操作，这时系统没什么压力，而第四种场景是数据库本来就要关闭了。这两种情况下不会太关注“性能”问题。所以主要分析一下前两种场景下的性能问题。

**InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态**：

1. 还没有使用的。
2. 使用了并且是干净页。
3. 使用了并且是脏页。

**InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。**

当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。

这时候只能把最久不使用的数据页从内存中淘汰掉：

- 如果要淘汰的是一个干净页，就直接释放出来复用。
- 但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。

**出现以下这两种情况，都是会明显影响性能的：**

1. **一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长。**
2. **日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。**

所以，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。

# InnoDB 刷脏页的控制策略

## innodb_io_capacity

**innodb_io_capacity 这个参数会告诉 InnoDB 磁盘能力。告诉 InnoDB 所在主机的 IO 能力，这样 InnoDB 才能知道需要全力刷脏页的时候，可以刷多快。**

这个值建议设置成磁盘的 IOPS（每秒的输入输出量）。磁盘的 IOPS 可以通过 fio 这个工具来测试，下面的语句是用来测试磁盘随机读写的命令：

```java
fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest 
```

## innodb_max_dirty_pages_pct

虽然已经定义了“全力刷脏页”的行为，**但不能一直是全力刷，毕竟磁盘能力不能只用来刷脏页，还需要服务用户请求。**

**InnoDB 怎么控制引擎按照“全力”的百分比来刷脏页？**

如果刷太慢，会出现什么情况？

首先是内存脏页太多，其次是 redo log 写满。

**所以，InnoDB 的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是 redo log 写盘速度。**

**参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%。**

InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，计算这个数字的伪代码类似这样：

```java
F1(M)
{
  if M>=innodb_max_dirty_pages_pct then
      return 100;
  return 100*M/innodb_max_dirty_pages_pct;
}
```

**InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值假设为 N。**

**InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。F2(N) 算法比较复杂，总之N 越大，算出来的值越大。**

然后，根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。

**合理地设置 innodb_io_capacity 的值，并且平时要多关注脏页比例，不要让它经常接近 75%。**

## 脏页比例

脏页比例是通过 Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total 得到的，具体的命令参考下面的代码：

```java
mysql> select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';
select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';
select @a/@b;
```

一旦一个查询请求需要在执行过程中先 flush 掉一个脏页时，这个查询就可能要比平时慢了。

## innodb_flush_neighbors

而 MySQL 中的一个机制，可能让你的查询会更慢：

**在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。**

在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的:

- 值为 1 的时候会有上述的“连坐”机制。
- 值为 0 时表示不找邻居，自己刷自己的。

**找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机 IO。机械硬盘的随机 IOPS 一般只有几百，相同的逻辑操作减少随机 IO 就意味着系统性能的大幅度提升。**

**而如果使用的是 SSD 这类 IOPS 比较高的设备的话，建议把 innodb_flush_neighbors 的值设置成 0。**

**因为这时候 IOPS 往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少 SQL 语句响应时间。**

在 MySQL 8.0 中，innodb_flush_neighbors 参数的默认值已经是 0 了。

# 提问

一个内存配置为 128GB、innodb_io_capacity 设置为 20000 的大规格实例，正常会建议你将 redo log 设置成 4 个 1GB 的文件。但如果你在配置的时候不慎将 redo log 设置成了 1 个 100M 的文件，会发生什么情况呢？又为什么会出现这样的情况呢？

**每次事务提交都要写 redo log，如果设置太小，很快就会被写满，这个“环”将很快被写满，write pos 一直追着 CP。**

**这时候系统不得不停止所有更新，去推进 checkpoint。这时，你看到的现象就是磁盘压力很小，但是数据库出现间歇性的性能下跌。**

